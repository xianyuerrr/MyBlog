---
title: 数据库面试常问知识点
tags:
  - 数据库
  - 面试
categories:
  - 计算机
comments: true
toc: true
aplayer: false
dplayer: false
date: 2021-09-02 13:39:05
cover: https://cdn.jsdelivr.net/gh/xianyuerrr/PicGo/img/OneDrive/图片/pixiv/89512744_p0.jpg
---
# 数据库

## 引擎

![mysql引擎区别](https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/202110010936468.png)

## 三范式

- 1NF：原子性
- 2NF：不存在部分依赖（e.g. A, B, C, D；B依赖A，D依赖C）
- 3NF：不存在传递依赖（e.g. A, B, C；B依赖A，C依赖B）

## 文件系统与数据库

**区别**在于：

(1)文件系统用文件将数据长期保存在外存上，数据库系统用数据库统一存储数据。

(2)文件系统中的程序和数据有一定的联系，数据库系统中的程序和数据分离。

(3)文件系统用操作系统中的存取方法对数据进行管理，数据库系统用DBMS统一管理和控制数据。

(4)文件系统实现以文件为单位的数据共享，数据库系统实现以记录和字段为单位的数据共享。

其**联系**在于：

(1)均为数据组织的管理技术。

(2)均由数据管理软件管理数据，程序与数据之间用存取方法进行转换。

(3)数据库系统是在文件系统的基础上发展而来的。

## 语句执行顺序

```
(8) SELECT (9)DISTINCT<Select_list>
(1) FROM <left_table> (3) <join_type>JOIN<right_table>
(2) ON<join_condition>
(4) WHERE<where_condition>
(5) GROUP BY<group_by_list>
(6) WITH {CUBE|ROLLUP}
(7) HAVING<having_condtion>
(10) ORDER BY<order_by_list>
(11) LIMIT<limit_number>
```



## 索引

![mysql索引](https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/202110010935533.png)

![mysql索引失效](https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/202110010934316.png)



索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而**不必扫描整个数据库**。

**唯一性索引和复合索引**

1. 唯一性索引：保证在索引列中的全部数据是唯一的，不会包含冗余数据。
2. 复合索引：一个索引创建在两个列或者多个列上。

**聚簇索引与非聚簇索引**

1. 聚簇索引：数据表的物理顺序与索引顺序相同
2. 非聚簇索引：数据表的物理顺序与索引顺序不相同

**优点**

① 创建唯一性索引可以保证行的**唯一性**

② **大大加快数据的检索速度**

③ 建立索引可以**加快表与表之间的连接**，在实现数据的参考完整性方面特别有意义

④ **加快分组和排序**

**缺点**

① 创建索引和维护索引需要**时间成本**，这个成本随着数据量的增加而加大

② 创建索引和维护索引需要**空间成本**，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大（数据表占据的是数据库的数据空间）

③ 每次增删改索引需要进行**动态维护**，会**降低表的增删改的效率**

**应该在这些列上创建索引**

1. 经常需要搜索、排序、使用Where的列上，加快搜索速度
2. 作为主键的列上，强制该列的唯一性
3. 经常用在连接的列上（主要是一些外键），可以加快连接的速度

**什么情况下需要建立索引**

1. 数据量大的，更新频率较低，经常进行查询操作的表要建立索引。
2. 用于排序的字段可以添加索引，用于分组的字段应当视情况看是否需要添加索引。
3. 表与表连接用于多表联合查询的约束条件的字段应当建立索引。

![mysql优化WHERE子句](https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/202110031520036.png)![mysql优化WHERE子句](https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/202110031520036.png)

## 为什么索引使用B+树而不是B树

B树：是特殊的平衡N叉树。

（1）每个节点最多有m个分支，如果是根节点且不是叶子结点，分枝数最少为2个；非根非叶子结点分枝数最少为m/2个。

（2）有n个分支的节点，就有n-1个关键字，关键字互不相等。

（3）关键字把子节点划分成一个个区间

（4）所有的叶子结点处于同一层

（5）新加节点和删除节点可能会进行树节点的合并和分裂。

B树的每一个节点都包含key和value，如果经常访问的元素离根节点很近，访问会很迅速。

B+树

（1）有k个子节点的节点必然有k个关键码。

（2）非叶子结点只有索引作用，跟数据有关的信息均存放在叶子结点上

（3）树的所有叶子结点构成一个双向有序链表，可以按照关键码的排序次序遍历所有记录。

B+树的内部节点没有指向关键字具体信息的指针，所以内部节点更小；如果把所有同一内部节点的关键字存在同一个盘块中，那么盘块所能容纳的关键字数量也就更多，一次性读入内存中需要查找的关键字也就更多，减少了IO读写次数。

B+树的叶子结点是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点就可以了。便于区间搜索和查找。

## 窗口函数

原则上只能写在select子句中

**group by分组汇总后改变了表的行数，一行只有一个类别。而partiition by和rank函数不会减少原表中的行数**

聚合函数sum在窗口函数中，是**对自身记录、及位于自身记录以上**的数据进行求和的结果

```
<窗口函数> over (partition by <用于分组的列名> order by <用于排序的列名>)
```

![img](https://raw.githubusercontent.com/xianyuerrr/PicGo/main/img/20210816171827.png)

**经典TOPN问题**：找出每个部门工资排名前N的员工

```
select *
from（select*，row_number() over (partition by 部门 order by salary desc) as ranking
from 表名) as a
where ranking<=N;
```


## 事务

是用户定义的一系列数据库操作，这些操作可以视为一个完成的逻辑处理工作单元，要么全部执行，要么全部不执行，是不可分割的工作单元。

**ACID**

原子性（要么都成功，要么都失败）、一致性（一致性状态变到另一个一致性状态）、隔离性（事务不能互相干扰）、持久性（改变是永久性的，写入磁盘）

**常见问题**

脏读：（读未提交）B读到了A**修改但未提交**的数据，但之后A因为回滚或者只是作为一个中间过程未提交

不可重复读：B多次读取同一个数据，但由于A对于此数据进行了修改，导致B的连续两次读取结果不一样

幻读：B多次查询数据库，A在B查询的间隔进行了数据的插入或删除，导致B的查询结果发生了变化，像幻觉一样

**隔离级别**

读未提交：事务修改的数据还未提交时，**变化**就能被其他事务读到

读提交：事务修改的数据提交之后，**变化**才能被其他事务读到

可重复读：事务执行过程中看到的数据，**与事务启动时看到的结果一致**，不会改变。当然自身未提交的变化其他事务也是读不到的

串行化：读写会加锁，出现冲突时，**只能等前一个事务执行完毕**才能执行

**MVCC**

多版本并发控制，是数据库控制并发访问的一种手段

只在 **读已提交(RC)** 和 **可重复度（RR）** 这两种事务隔离级别下才有效

## 视图

是虚拟的表，本身不包含数据，也就不能对其进行索引操作。

对视图的操作和对普通表的操作一样。

视图具有如下好处：

- 简化复杂的 SQL 操作，比如复杂的连接；
- 只使用实际表的一部分数据；
- 通过只给用户访问视图的权限，保证数据的安全性；
- 更改数据格式和表示。
